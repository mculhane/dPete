# Final write-up

## Introduction

dPete is applicable to anyone with a regular schedule and recurring deadlines. One particular set of users with these requirements is students. Students have a set of classes with predictable deadlines for problem sets, readings, and class preparation. These users need a tool to keep track of all of these deadlines and to let them know when they need to be working on the tasks. Our tool, dPete, aims to do just this. dPete allows users to enter a set of single, recurring, and dependent tasks once. Then, using these tasks, their time information, and the current time, dPete calculates everything that the user could be working on at the moment. This alleviates the burden on the user of having to keep track of deadlines and due dates.

Our tool is targeted at a fairly technical audience, most directly our peers. As a result, we did not have qualms about implementing our language to use many of the tools, technologies, and expected syntax of a programming language. In fact, we felt that our users would feel familiar with a tool that allowed them the flexibility of a programming language and the quickness of exclusively keyboard input. This analysis of our domain led us to create a language and sample implementation that should fit nicely into student workflow.


## Language Design Details
With our language, the user writes programs (which consist of specifications of tasks and their dependencies) in plain text. We have provided a Sublime Text plugin that will aid in the process of writing programs by providing syntax highlighting and formatting assistance to the user. Our language computes the things that a user should be working on and displays only valid tasks. This deemphasize the things that a user cannot currently be working on. The user can tag tasks as completed and these will be stored in a separate file in order to help the user stay organized.

The tasks are simply stored in a list and there is no manipulable control flow. A user enters statements that all have the same basic structure. The only control flow occurs when a user desires dependencies or recurrences. In the case of dependencies, tasks’ start and due dates will depend on computations in the tasks that they depend on. Furthermore, recurrences provide a sort of looping, as recurrences specify the interval of repetition for a task. (Interestingly enough, our language only includes recurrence interval specification, but not anything regarding the number of recurrences, so all recurrences will recur infinitely. Because of how a program is run, though, this will not cause any sort of infinite looping behavior.)

Our program requires a number of lines of text as input and produces lines of text as output. More specifically, the input to our language is a series of tasks specified with their dependencies and recurrences (in plain text), and the output is a plain text list of the next-due tasks (along with any error messages indicating issues encountered).

In designing our language, we have tried to minimize any potential conceptual errors. Misunderstanding, which occurs when the program’s behavior and the user’s intent are different, has been one of our largest concerns. A user can tolerate an error---they would be notified that something was wrong immediately---but if the system misunderstands the user then we could not produce a reminder when the user is expecting one, losing their trust forever. 

We have tried to make our syntax as unambiguous as possible in order to minimize misunderstandings. This has required some rigidities of expression. We have already eliminated a few language features which we thought would introduce unnecessary confusion. Furthermore, when designing our semantics, we have had this issue in mind. We initially thought about how we should interpret syntactically correct expressions with unclear meaning (such as a task that starts on Monday and is due on Friday, yet repeats every Tuesday). After spending some time constructing ridiculous potential interpretations, though, we realized that whatever decision we made would never be obvious to the user. In order to mitigate this issue, we have decided to disallow semantically ambiguous cases. Where possible, we have done this via constraints on the syntax. Elsewhere, it is enforced via checks in the semantics. In this particular case, we have decided that a recurrence interval for a task must be larger than the difference between the start and due dates for that task. So, if you specify a task that starts and is due in 6 days, then the recurrence interval has to be weekly or monthly rather than hourly or daily. Similarly, we have constructed the syntax such that dependent tasks’ start and due dates can (and must) depend on exactly one other task. This removes the confusing case in which a task’s start and due dates depend on different tasks with potentially different recurrence intervals. Our decision to avoid cases of semantic ambiguity is consistent with our goal of maintaining clarity above everything else (including a larger feature set).

Our tool provides both error checking and a development environment for the user. Error checking is performed during runtime at both the syntactic level (in the parser) and the semantic level. Furthermore, our Sublime Text plugin serves as a development environment of sorts for the user. The key features of the plugin are syntax highlighting (which provides a quick way to verify syntax) and “snippets” which provide the basic structure of a task and allow the user to tab between parts to add details. (This allows the user to add tasks without needing to remember the details of the syntax.) In addition to these core features, the Sublime Text plugin takes care of some of the more tedious parts of writing in our language like choosing hashes for tasks. The plugin allows us to support dates relative to the current time (like “tomorrow”). (Without such a development environment, such dates would clearly change based on when the file is viewed, so we would not be able to support them.)

There are several sorts of issues that might be encountered with a program in our domain. If we decide to infer dependencies between tasks, there may be errors concerning the program’s interpretation of relationships between tasks that would be used to calculate those dependencies. In order to prevent errors like this we have to make sure that the way in which the inputs are formatted and the information that is required by the users must be clearly articulated so that the language can parse the inputs and produce an accurate and useful dependency model. It may also be possible that a user specifies a dependency between tasks that are not otherwise defined, which should likely be caught as either a compile-time or runtime error. Furthermore, it is possible that a user could define cyclical dependencies, which would create a sort of deadlock. We cannot assume cyclical dependencies to be an error, though, as it’s feasible that such a problematic situation truly exists. Thus, cyclical dependencies should be handled at runtime. In all of these cases, there are ways of defining the syntax that could prevent the errors from occurring, and we will keep this in mind when designing our syntax. 

Our tool is a strong improvement on other popular task management platforms. Existing tools make the specification of project dependencies and recurrences a very slow, verbose, and involved process. Many current tools also limit the sorts of dependencies that can be expressed or make the process so tedious that specifying dependencies isn’t worth the effort. Some tools also do not support recurring events at all. Todo.txt, a similarly structured task DSL to ours, allows for rich specification of task context but also does not support recurrences or dependencies natively. Some implementations of Todo.txt do support due dates and recurrences, but the support is limited and feels tacked-on. We briefly considered using the Todo.txt specification as a base for our language, but we quickly realized that building a separate language would be a better choice. (We made this decision both because we wanted to make dependencies and recurrences first-class citizens of our language and because we had little interest in building on top of TODO.txt’s unwieldy shell-script implementation.) In any case, the core ideas of todo.txt (a human readable and editable plain text task list specified in a straightforward way) are ideas that we have tried to preserve in our language.

In addition to TODO.txt, which is a more clear-cut language, we have also looked at several examples of task management software to garner an understanding of how they use dates and dependencies. For example, Google Tasks provides a simple way to assign tasks to dates, but it does not support dependencies or recurring tasks. Another language that is somewhat related to our DSL is GNU Make. Like our DSL, GNU Make is concerned with the idea of dependencies, namely dependencies that must be resolved to construct executables for programs. The key feature of GNU Make that we find compelling is that even though it operates upon a DAG of dependencies, that DAG is not explicitly provided by the programmer. Rather, the programmer lists out the dependencies for each node, one at a time. Perhaps most importantly, the syntax of GNU Make has given us the insight that a dependency graph need not be explicitly specified as such. Instead, we can think about how the dependencies can be most easily specified by the user. This has helped us decide that it would be cognitively simpler to specify dependencies task by task instead of trying to specify the entire dependency graph at once. Finally, Taskwarrior is a surprisingly full-featured task management system for the command line, which has robust support for recurrences. It handles dependencies as well by allowing the user to specify a list of tasks which a task depends on, which is very similar to the type of behavior we would like to support. In a sense, then, this analysis has demonstrated to us that we would like to support the dependencies and recurrences with the robustness of Taskwarrior, but with the concise and intuitive syntax of TODO.txt.


## Example Program
The following is an example of a program in our language:
```
#AAA Task AAA @ 12/09/2014 - 12/13/2014 % every 1 week
#AFD Task AFD ^ #AAA Start+0 days, Due+0 days
#CAS Task CAS ^ #CAS Start+2 days, Due+2 days
#AFD Task AFD @ 12/09/2014 - 12/13/2014
```
This sample program describes four separate tasks. Each task starts with a hash, which is an arbitrarily long alphanumeric string that is unique to the task.

The first task (#AAA) highlights the syntax for a recurring task. It describes a task with description “Task AAA” that starts on December 9, 2014 and is due on December 13, 2014. The task repeats weekly.

The second and third tasks (#AFD) highlight the syntax for dependent tasks. Task #AFD depends on #AAA and has start and due dates which are the same as #AAA’s. Similarly, #CAS depends on #AFD and has start and due dates two days after #AFD. Because both #CAS and #AFD are ultimately dependent on #AAA, which is a recurring task, #AFD and #CAS recur as well.

The fourth task (#AFD) demonstrates the syntax for a non-recurring task. It describes a one-time task that starts on December 9, 2014 and is due on December 13, 2014.


## Language Implementation

For our language, we decide to use a hybrid approach for the host language. The core algorithmic function of the language is implemented in Scala. This part of the language calculates what tasks need to appear on the task list. However, we also use a Python based plug-in for Sublime Text as an integral part of our language. This integrated approach allows us to make context-based decisions about what to display and when to display it in the Python plug-in. We also get to take advantage of the strong parsing and data processing features of Scala.

We felt that we needed an IDE for our language in order to implement specialized features, such as relative date calculation (such as "tomorrow" or "next Tuesday"), that would not have been possible to implement in an environment that did not do processing on the input text at the same time that it is input. Our decision to use Sublime stems from domain analysis: we want to target our tool at students who are fairly technical in their training. We found it likely that these students would already have Sublime Text installed on their systems. If they do not have Sublime, it is also a lightweight tool that they could install specifically for this purpose.

We chose Scala for our language's backend because of its strong parsing and data processing skills. Its concise syntax is also appreciated. Our team is also fairly familiar with the language which reduces the time required to bootstrap the project.

A user could decide to make use of strictly the Scala part of the language. However, the user could not then take advantage of any of the sugary features we have developed to make things easier for the user. These features include the relative date calculation (such as "tomorrow" or "next Tuesday") and input/output formatting. The Scala portion of the language is designed to function as a regular unix utility however, so a user could design their own frontend for the Scala portion that implements enhancements that they find useful. It would not be hard to implement frontends for the Scala package for other IDEs. 

Our language is an external DSL. We needed a dedicated, platform-independent syntax to have any chance of our language being widely adopted. Each member of our target audience has a very specific workflow with regard to tasks. They will not be willing to make large changes to integrate our tool into their workflow. As a result, our language and tool set need to be flexible and extensible in order to be attractive to a wide variety of people. An internal DSL would be too restrictive for these use cases.

Our language has two levels of parsing. First, the Sublime Text plugin does some preliminary parsing of relative dates (such as “tomorrow”) to replace them with timestamps that will not vary with time. The rest of the parsing is done in our Scala parsing package. In Scala, parsing is done using parser combinators, which convert the input text into the intermediate representation, which is defined as a series of case classes in Scala. We have case classes for individual tasks, for dates, and for recurrences. The highest-level case class is the TaskList, which stores a list of task objects.

The semantics of the language works by performing a variety of operations on the list of tasks. At the outset, though, the semantics package starts by constructing an additional data structure for resolving dependencies. This data structure (which we call a “task dictionary”) is a map of task hashes to task objects. Once the task dictionary is constructed, the program validates each task by making sure that it makes semantic sense. This includes making sure that a task’s due date falls after its start date and ensuring that a task’s “active duration” (the temporal difference between its start and due dates) is less than its recurrence interval. (Requiring the “active duration” to be less than the recurrence interval certainly restricts the types of recurrences we allow, but it provides a much clearer model for how recurrences should work and it means that only one instance of a recurrence is active at a time.) Once the semantically incorrect tasks have been filtered out (and error messages have been printed indicating this), the semantics resolves the due dates of the tasks. This date resolution involves recursing to calculate due dates of dependencies (and any necessary offsets) and also determining the appropriate dates for the current instance of a recurring task. Then, the language sorts the task list by the calculated due dates and returns a nicely-formatted line for each resulting task.

Our language executes while the user is entering their program. As our output is simply a list of tasks, we try to keep the user as up to date as possible with regard to their list. So, we use a simple command structure to aid in entering tasks. Whenever the user saves, our implementation re-runs computations on the input tasks so that the tasks list output is kept up to date.


## Evaluation

Overall, we are rather satisfied with our language. There will always be facets of the language that we would like to tweak (such as adding more features or improving testing and error handling), but our overall prototype is a usable proof of concept that demonstrates our approach to text-based task management with recurrences and dependencies. Our final product is incredibly DSL-y. We have tailored the syntax and the semantics to the domain of task management (and trying to compute anything outside of this narrow domain with our language would likely be a rather painful task).

We are very pleased with several aspects of our language. Through constant iterative improvement, we have arrived at a reasonably solid semantic model for recurring and dependent tasks. Modeling dependencies between recurring tasks is something that most existing task management systems do not do, and it was one of the core goals of this project, and we have come up with intuitive semantics to handle this complicated case. Coming up with such an intuitive semantic model forced us to exclude several cases we had originally hoped to consider, but the resulting clarity allows users to be more confident in the behavior of the language, which is a clear advantage. We are also very happy with our Sublime Text plugin, which makes interacting with the language very easy and straightforward. Our language has a very terse and concise syntax, which makes entering tasks quick and easy. That said, though, there can be a bit of a learning curve with the syntax because it is not particularly explicit (and this was a consistent theme in our user tests). The Sublime Text plugin effectively mitigates this problem by providing useful snippets for text entry.

The primary place where our language could be improved is in its robustness. Our parser is not particularly forgiving, for example, and tasks that are not entered exactly according to our syntax will not be parsed properly. It would be nice if, for example, a recurrence interval could be specified before a task’s start and due dates. (This would be syntactically unambiguous because each component of a task is marked with a starting character like “%” or “@”.)  With more time, our primary focus would be on additional testing and more robust error handling. Other than that, though, we are pleased with the functionality we have. We would like to expand the language, though. To achieve feature parity with todo.txt (the other text-based task management language), it would be nice to add projects and tags to the language. Finally, we would like to add additional querying functionality to the language. Currently, the language only identifies next-due tasks, but we can imagine a variety of interesting queries that users would like to construct.

The main tools that we have used to evaluate the quality of our language include the in-class user testing and our own personal usage of the language. We have learned a lot from the user testing, including the fact that our syntax can be a bit confusing. (We resolved this issue with more suggestive snippets in the Sublime Text plugin.) We have also relied on unit tests to judge the correctness of our language. We have come up with several test cases to evaluate key parts of the language. There have even been several cases in which we made breaking changes to the language during development, and the unit tests alerted us to these issues. In the interest of time, we decided to forego user tests for the Sublime Text plugin, instead relying on extensive manual testing. Manual testing with our sample programs encompasses all of the language’s core use cases, allowing us to simulate and analyze the user experience.

While developing dPete, we certainly ran into our fair share of trouble. At the beginning of our project, we ran into trouble with our initial choice of Python as a host language. The library that allowed us to use case classes resulted in code that was extremely verbose and hard to understand. Furthermore, the library worked by modifying Python’s abstract syntax tree, which we found to be a janky and error-prone solution. We fixed this issue by switching to Scala, which had native support for functional programming that we were seeking. Our Scala code is much shorter and cleaner than the Python equivalent. We also ran into trouble coming up with an execution model for our language, as we wanted the user to be able to interact with the language via the Sublime Text plugin (suggesting that we should be able to modify data structures and recompute results on the fly). We eventually realized, though, that our target users (people managing their current and upcoming personal tasks) would have no more than a few hundred tasks in a program at most. With this in mind, we realized that we could simply recompute everything each time the user makes a change. While this is not asymptotically optimal (and it does result in “wasted” CPU cycles), it provides the desired behavior and allows us to design the language in a much simpler fashion.

We worked as a team of three for this project, so we split up each week’s work into approximately three equal pieces. For the majority of the project, these three components were the parser, the semantics and the Sublime Text plugin. We constructed the intermediate representation as a team (and doing this allowed us to simultaneously develop the parser and the semantics. Towards the end of the project, we also incorporated documentation writing into the parts of the project that we split up. In addition to dividing much of the work, we also had approximately two meetings per week in which we worked on the project as a team. These team meetings usually consisted of design discussions in which we settled on the semantics of the language, syntax details, and the particulars of the intermediate representation. These team meetings were extraordinarily useful for as, as they gave us an opportunity to debate design ideas and iterate until we arrived at solutions we were all satisfied with. We spent roughly one third of our weekly time in team meetings and the other two thirds working independently on the language.
